// <auto-generated />
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Operations;

namespace EnumRecords.Analyzers;

/// <summary>
/// Analyzer that enforces [RequireEnumRecord&lt;TInterface&gt;] constraints at compile time.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class EnumRecordConstraintAnalyzer : DiagnosticAnalyzer
{
    /// <summary>
    /// ENUMREC010: Reported when a concrete enum type argument doesn't satisfy the required EnumRecord constraint.
    /// </summary>
    public static readonly DiagnosticDescriptor MissingEnumRecordInterface = new(
        id: "ENUMREC010",
        title: "Enum missing required EnumRecord interface",
        messageFormat: "Type '{0}' must have [EnumRecord<T>] where T implements '{1}'",
        category: "EnumRecords",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "The enum type used as a type argument does not have an EnumRecord with properties implementing the required interface.");

    /// <summary>
    /// ENUMREC011: Reported when a generic method passes its type parameter to a constrained method without propagating the constraint.
    /// </summary>
    public static readonly DiagnosticDescriptor MissingConstraintPropagation = new(
        id: "ENUMREC011",
        title: "Missing EnumRecord constraint propagation",
        messageFormat: "Method '{0}' calls '{1}' which requires [RequireEnumRecord<{2}>], but '{0}' lacks this constraint. Add [RequireEnumRecord<{2}>] to '{0}' to propagate the constraint.",
        category: "EnumRecords",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "When a generic method passes its type parameter to another method with [RequireEnumRecord<T>], the calling method must also have the constraint to ensure type safety throughout the call chain.");

    /// <summary>
    /// ENUMREC012: Reported when an enum type doesn't have any EnumRecord at all.
    /// </summary>
    public static readonly DiagnosticDescriptor MissingEnumRecord = new(
        id: "ENUMREC012",
        title: "Enum missing EnumRecord attribute",
        messageFormat: "Type '{0}' does not have an [EnumRecord<T>] attribute",
        category: "EnumRecords",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "The enum type used as a type argument does not have an [EnumRecord<T>] attribute.");

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
        ImmutableArray.Create(MissingEnumRecordInterface, MissingConstraintPropagation, MissingEnumRecord);

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterOperationAction(AnalyzeInvocation, OperationKind.Invocation);
    }

    private void AnalyzeInvocation(OperationAnalysisContext context)
    {
        if (context.Operation is not IInvocationOperation invocation)
            return;

        var targetMethod = invocation.TargetMethod;

        // Get all [RequireEnumRecord<T>] attributes on the target method
        var constraints = GetRequireEnumRecordConstraints(targetMethod);
        if (constraints.Count == 0)
            return;

        // Get the containing method (if any) to check for propagation
        var containingMethod = context.ContainingSymbol as IMethodSymbol;

        foreach (var constraint in constraints)
        {
            var typeParamIndex = constraint.TypeParameterIndex;
            var requiredInterface = constraint.RequiredInterface;

            if (typeParamIndex >= targetMethod.TypeArguments.Length)
                continue;

            var typeArg = targetMethod.TypeArguments[typeParamIndex];

            // Case 1: Concrete enum type — validate directly
            if (typeArg.TypeKind == TypeKind.Enum)
            {
                var validationResult = ValidateEnumHasRequiredInterface(typeArg, requiredInterface);
                
                if (!validationResult.HasEnumRecord)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        MissingEnumRecord,
                        invocation.Syntax.GetLocation(),
                        typeArg.Name));
                }
                else if (!validationResult.ImplementsInterface)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        MissingEnumRecordInterface,
                        invocation.Syntax.GetLocation(),
                        typeArg.Name,
                        requiredInterface.Name));
                }
            }
            // Case 2: Type parameter — require propagation
            else if (typeArg.TypeKind == TypeKind.TypeParameter && containingMethod != null)
            {
                // Check if the containing method has the same or compatible constraint
                if (!HasCompatibleConstraint(containingMethod, requiredInterface))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        MissingConstraintPropagation,
                        invocation.Syntax.GetLocation(),
                        containingMethod.Name,
                        targetMethod.Name,
                        requiredInterface.Name));
                }
            }
        }
    }

    private record struct ConstraintInfo(int TypeParameterIndex, ITypeSymbol RequiredInterface);

    private static List<ConstraintInfo> GetRequireEnumRecordConstraints(IMethodSymbol method)
    {
        var constraints = new List<ConstraintInfo>();

        foreach (var attr in method.GetAttributes())
        {
            if (attr.AttributeClass is not INamedTypeSymbol attrClass)
                continue;

            if (!attrClass.IsGenericType)
                continue;

            if (attrClass.Name != "RequireEnumRecordAttribute" || 
                attrClass.ContainingNamespace?.ToDisplayString() != "EnumRecords")
                continue;

            if (attrClass.TypeArguments.Length != 1)
                continue;

            var requiredInterface = attrClass.TypeArguments[0];

            // Get TypeParameterIndex from named arguments (defaults to 0)
            var typeParamIndex = 0;
            var indexArg = attr.NamedArguments.FirstOrDefault(a => a.Key == "TypeParameterIndex");
            if (indexArg.Key != null && indexArg.Value.Value is int idx)
            {
                typeParamIndex = idx;
            }

            constraints.Add(new ConstraintInfo(typeParamIndex, requiredInterface));
        }

        // Also check containing type for class-level constraints
        if (method.ContainingType != null)
        {
            foreach (var attr in method.ContainingType.GetAttributes())
            {
                if (attr.AttributeClass is not INamedTypeSymbol attrClass)
                    continue;

                if (!attrClass.IsGenericType)
                    continue;

                if (attrClass.Name != "RequireEnumRecordAttribute" ||
                    attrClass.ContainingNamespace?.ToDisplayString() != "EnumRecords")
                    continue;

                if (attrClass.TypeArguments.Length != 1)
                    continue;

                var requiredInterface = attrClass.TypeArguments[0];

                var typeParamIndex = 0;
                var indexArg = attr.NamedArguments.FirstOrDefault(a => a.Key == "TypeParameterIndex");
                if (indexArg.Key != null && indexArg.Value.Value is int idx)
                {
                    typeParamIndex = idx;
                }

                constraints.Add(new ConstraintInfo(typeParamIndex, requiredInterface));
            }
        }

        return constraints;
    }

    private record struct ValidationResult(bool HasEnumRecord, bool ImplementsInterface);

    private static ValidationResult ValidateEnumHasRequiredInterface(ITypeSymbol enumType, ITypeSymbol requiredInterface)
    {
        // Find [EnumRecord<T>] attribute on the enum
        var enumRecordAttr = enumType.GetAttributes()
            .FirstOrDefault(a =>
                a.AttributeClass is INamedTypeSymbol attrClass &&
                attrClass.IsGenericType &&
                attrClass.Name == "EnumRecordAttribute" &&
                attrClass.ContainingNamespace?.ToDisplayString() == "EnumRecords");

        if (enumRecordAttr?.AttributeClass is not INamedTypeSymbol { TypeArguments.Length: 1 } attrType)
        {
            return new ValidationResult(HasEnumRecord: false, ImplementsInterface: false);
        }

        // Get the properties type from EnumRecord<TProperties>
        var propertiesType = attrType.TypeArguments[0];

        // Check if properties type implements the required interface
        var implementsInterface = propertiesType.AllInterfaces
            .Any(i => SymbolEqualityComparer.Default.Equals(i, requiredInterface));

        // Also check if the properties type IS the required interface (direct implementation)
        if (!implementsInterface)
        {
            implementsInterface = SymbolEqualityComparer.Default.Equals(propertiesType, requiredInterface);
        }

        return new ValidationResult(HasEnumRecord: true, ImplementsInterface: implementsInterface);
    }

    private static bool HasCompatibleConstraint(IMethodSymbol method, ITypeSymbol requiredInterface)
    {
        var methodConstraints = GetRequireEnumRecordConstraints(method);

        foreach (var constraint in methodConstraints)
        {
            // Check for exact match or if the method's constraint is a subtype
            if (SymbolEqualityComparer.Default.Equals(constraint.RequiredInterface, requiredInterface))
                return true;

            // Check if the method's constraint inherits from the required interface
            if (constraint.RequiredInterface.AllInterfaces
                .Any(i => SymbolEqualityComparer.Default.Equals(i, requiredInterface)))
                return true;
        }

        return false;
    }
}
